/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.example.mapapplication.originCode.net.models

import com.example.mapapplication.originCode.net.models.PeliasGeoJSONPropertiesAddendum
import com.example.mapapplication.originCode.net.models.PeliasLayer
import com.google.gson.annotations.SerializedName

/**
 * 
 *
 * @param gid A scoped GID for this result. This can be passed to the place endpoint. Note that these are not always stable. For OSM, Geonames, and Who's on First, these are usually stable, but for other sources like OSM, no stability is guaranteed.
 * @param sourceId An ID referencing the original data source (specified via source) for the result. These IDs are specific to the source that they originated from. For example, in the case of OSM, these typically look like way/123 or point/123.
 * @param label A full, human-readable label. However, you may not necessarily want to use this; be sure to read the docs for name, locality, and region before making a decision. This field is mostly localized. The order of components is generally locally correct (ex: for an address in South Korea, the house number appears after the street name). However, components will use a request language equivalent if one exists (ex: Seoul instead of 서울 if lang=en).
 * @param layer 
 * @param name The name of the place, the street address including house number, or label of similar relevance. If your app is localized to a specific region, you may get better display results by combining name, locality OR region (or neither?), and postal code together in the local format. Experiment with what works best for your use case.
 * @param accuracy The accuracy of the geographic coordinates in the result. This value is a property of the result itself and won't change based on the query. A point result means that the record can reasonably be represented by a single geographic point. Addresses, venues, or interpolated addresses usually have point accuracy. Larger areas, such as a city or country, cannot be represented by a single point, so a centroid is given instead.
 * @param addendum 
 * @param continent 
 * @param continentGid 
 * @param country 
 * @param countryGid 
 * @param neighbourhood 
 * @param neighbourhoodGid 
 * @param borough 
 * @param boroughGid 
 * @param postalcode 
 * @param street 
 * @param housenumber 
 * @param locality The city, village, town, etc. that the place / address is part of. Note that values may not always match postal or local conventions perfectly.
 * @param localityGid 
 * @param county Administrative divisions between localities and regions. Useful for disambiguating nearby results with similar names.
 * @param region Typically the first administrative division within a country. For example, a US state or a Canadian province.
 * @param regionA The abbreviation for the region.
 */


data class PeliasGeoJSONProperties (

    /* A scoped GID for this result. This can be passed to the place endpoint. Note that these are not always stable. For OSM, Geonames, and Who's on First, these are usually stable, but for other sources like OSM, no stability is guaranteed. */
    @SerializedName("gid")
    val gid: kotlin.String? = null,

    /* An ID referencing the original data source (specified via source) for the result. These IDs are specific to the source that they originated from. For example, in the case of OSM, these typically look like way/123 or point/123. */
    @SerializedName("source_id")
    val sourceId: kotlin.String? = null,

    /* A full, human-readable label. However, you may not necessarily want to use this; be sure to read the docs for name, locality, and region before making a decision. This field is mostly localized. The order of components is generally locally correct (ex: for an address in South Korea, the house number appears after the street name). However, components will use a request language equivalent if one exists (ex: Seoul instead of 서울 if lang=en). */
    @SerializedName("label")
    val label: kotlin.String? = null,

    @SerializedName("layer")
    val layer: PeliasLayer? = null,

    /* The name of the place, the street address including house number, or label of similar relevance. If your app is localized to a specific region, you may get better display results by combining name, locality OR region (or neither?), and postal code together in the local format. Experiment with what works best for your use case. */
    @SerializedName("name")
    val name: kotlin.String? = null,

    /* The accuracy of the geographic coordinates in the result. This value is a property of the result itself and won't change based on the query. A point result means that the record can reasonably be represented by a single geographic point. Addresses, venues, or interpolated addresses usually have point accuracy. Larger areas, such as a city or country, cannot be represented by a single point, so a centroid is given instead. */
    @SerializedName("accuracy")
    val accuracy: Accuracy? = null,

    @SerializedName("addendum")
    val addendum: PeliasGeoJSONPropertiesAddendum? = null,

    @SerializedName("continent")
    val continent: kotlin.String? = null,

    @SerializedName("continent_gid")
    val continentGid: kotlin.String? = null,

    @SerializedName("country")
    val country: kotlin.String? = null,

    @SerializedName("country_gid")
    val countryGid: kotlin.String? = null,

    @SerializedName("neighbourhood")
    val neighbourhood: kotlin.String? = null,

    @SerializedName("neighbourhood_gid")
    val neighbourhoodGid: kotlin.String? = null,

    @SerializedName("borough")
    val borough: kotlin.String? = null,

    @SerializedName("borough_gid")
    val boroughGid: kotlin.String? = null,

    @SerializedName("postalcode")
    val postalcode: kotlin.String? = null,

    @SerializedName("street")
    val street: kotlin.String? = null,

    @SerializedName("housenumber")
    val housenumber: kotlin.String? = null,

    /* The city, village, town, etc. that the place / address is part of. Note that values may not always match postal or local conventions perfectly. */
    @SerializedName("locality")
    val locality: kotlin.String? = null,

    @SerializedName("locality_gid")
    val localityGid: kotlin.String? = null,

    /* Administrative divisions between localities and regions. Useful for disambiguating nearby results with similar names. */
    @SerializedName("county")
    val county: kotlin.String? = null,

    /* Typically the first administrative division within a country. For example, a US state or a Canadian province. */
    @SerializedName("region")
    val region: kotlin.String? = null,

    /* The abbreviation for the region. */
    @SerializedName("region_a")
    val regionA: kotlin.String? = null

) : kotlin.collections.HashMap<String, kotlin.Any>() {

    /**
     * The accuracy of the geographic coordinates in the result. This value is a property of the result itself and won't change based on the query. A point result means that the record can reasonably be represented by a single geographic point. Addresses, venues, or interpolated addresses usually have point accuracy. Larger areas, such as a city or country, cannot be represented by a single point, so a centroid is given instead.
     *
     * Values: point,centroid
     */
    enum class Accuracy(val value: kotlin.String) {
        @SerializedName(value = "point") point("point"),
        @SerializedName(value = "centroid") centroid("centroid");
    }
}

